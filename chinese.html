<html>
<head>
    <title>Doc Test</title>
    <link href='css/mars.css' rel='stylesheet'/>
</head>
<body>
    <div class="document" id="restructuredtext">
<h1 class="title">reStructuredText 入门</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">origin:</th><td class="field-body"><a class="reference external" href="http://docspy3zh.readthedocs.org/en/latest/_sources/documenting/rest.txt">http://docspy3zh.readthedocs.org/en/latest/_sources/documenting/rest.txt</a></td>
</tr>
</tbody>
</table>
<p>本节将简要介绍 reStructuredText (reST) 的基本概念与语法,
尽量使作者可以掌握足够信息并能够有效的编写文档.
因为 reST 设计的目标就是简单, 没有太多要求的标记语言, 所以不会花费很长时间.</p>
<div class="section" id="id1">
<h1>段落</h1>
<p>在 reST 中, 段落是最基本的块. 段落是以一个或多个空行来分割.
就像在 Python 中一样, 缩进也是 reST 中的一个特色, 所以所有具有相同
缩进级别的行属于同一段落.</p>
</div>
<div class="section" id="id2">
<h1>行内标记</h1>
<p>标准的行内标记非常简单: 使用</p>
<ul class="simple">
<li>一个星号: <tt class="docutils literal">*text*</tt> 表强调 (斜体),</li>
<li>两个星号: <tt class="docutils literal">**text**</tt> 表更强的强调 (粗体), 并且</li>
<li>反引号: <tt class="docutils literal">``text``</tt> 表示代码实例.</li>
</ul>
<p>如果星号或者反引号出现在文本中, 但可能与行内标记有冲突,
那么他们需要使用一个反斜杠进行转义.</p>
<p>注意这种标记的一些限制:</p>
<ul class="simple">
<li>不能够嵌套,</li>
<li>里面的内容不能以空格开头或结尾: <tt class="docutils literal">* test*</tt> 是错的,</li>
<li>在这些的周围必须要以非单词字符分割.
使用一个反斜杠来转义一个空格就可以了: <tt class="docutils literal">thisis\ *one*\ word</tt>.</li>
</ul>
<p>这些限制可能会在以后被去掉.</p>
<p>reST 同样允许自定义的 &quot;interpreted text roles&quot;,
这就意味着围起来的文字可以以特殊的方式进行解释.
Sphinx 使用了这个提供了语义标记, 和交叉引用的标识符,
在下面的章节中将会提及. 一般的语法是 <tt class="docutils literal"><span class="pre">:rolename:`content`</span></tt>.</p>
</div>
<div class="section" id="id3">
<h1>列表和引用</h1>
<p>列表的标记是很自然的: 把星号放在每个段落的起始处,并使用合适的缩进.
同样, 这也适合有序的列表; 它们可以使用 <tt class="docutils literal">#</tt> 符号进行自动编号:</p>
<pre class="literal-block">
* This is a bulleted list.
* It has two items, the second
  item uses two lines.

1. This is a numbered list.
2. It has two items too.

#. This is a numbered list.
#. It has two items too.
</pre>
<p>嵌套的列表是可以的, 但是注意它们必须要与父列表以空行分割:</p>
<pre class="literal-block">
* this is
* a list

  * with a nested list
  * and some subitems

* and here the parent list continues
</pre>
<p>定义列表像下面这样定义:</p>
<pre class="literal-block">
term (up to a line of text)
   Definition of the term, which must be indented

   and can even consist of multiple paragraphs

next term
   Description.
</pre>
<p>引用的段落只需相对于周围的段落有缩进就可以了.</p>
</div>
<div class="section" id="id4">
<h1>源代码</h1>
<p>源代码以一个特殊的标记 <tt class="docutils literal">::</tt> 开始. 而且代码必须要缩进:</p>
<pre class="literal-block">
This is a normal text paragraph. The next paragraph is a code sample::

   It is not processed in any way, except
   that the indentation is removed.

   It can span multiple lines.

This is a normal text paragraph again.
</pre>
<p>处理 <tt class="docutils literal">::</tt> 会很智能:</p>
<ul class="simple">
<li>如果在段落中出现, 那么这个段落还是完整的保留下来.</li>
<li>如果前面有空格, 那么这个标记就被删除了.</li>
<li>如果前面不是空格, 那么就会被替换成一个冒号.</li>
</ul>
<p>那么, 上面的那句例子就会成为如 &quot;The next paragraph is a code sample:&quot;
的样子.</p>
</div>
<div class="section" id="id5">
<h1>超链接</h1>
<div class="section" id="id6">
<h2>外部链接</h2>
<p>使用 <tt class="docutils literal">`链接文字 <span class="pre">&lt;http:://target&gt;`_</span></tt> 作为网页链接.
如果链接文字是一个网页的地址, 那么你就不需要特殊的标记了,
解析器会帮助你找到链接和邮件地址.</p>
</div>
<div class="section" id="id7">
<h2>内部链接</h2>
<p>内部链接可以使用 reST 的特殊标记, 参考特殊标记的那节, <em>:ref:`doc-ref-role`.</em></p>
</div>
</div>
<div class="section" id="id8">
<h1>章节</h1>
<p>章节的标题使用在标题下放置一个字符来创建, 而此字符至少要和文本一样长:</p>
<pre class="literal-block">
=================
This is a heading
=================
</pre>
<p>一般来说, 没有非常明确的要求需要使用哪种符号来指明不同级别的标题.
但是, 对于 Python 文档来说, 我们使用这种约定:</p>
<ul class="simple">
<li><tt class="docutils literal">#</tt> with overline, for parts</li>
<li><tt class="docutils literal">*</tt> with overline, for chapters</li>
<li><tt class="docutils literal">=</tt>, for sections</li>
<li><tt class="docutils literal">-</tt>, for subsections</li>
<li><tt class="docutils literal">^</tt>, for subsubsections</li>
<li><tt class="docutils literal">&quot;</tt>, for paragraphs</li>
</ul>
</div>
<div class="section" id="id9">
<h1>显式的标记</h1>
<p>在 reST 中, &quot;Explicit markup&quot; 用于那些需要额外处理的构造,
比如脚注, 特殊高亮的段落, 注释, 和通用的指示符.</p>
<p>一个显式的标记块一般以 <tt class="docutils literal">..</tt> 开始, 然后后面跟着空白,
并且以与其相同级别的缩进表示结束. (当然,
此处我们还需要一个空白行来分隔标记块与正常的段落.
这可能听起来有点复杂, 但是当你写它的时候, 它就变得非常直观.)</p>
</div>
<div class="section" id="id10">
<h1>指示符</h1>
<p>一个指示符就是一个普通的显式标记块. 它是一个 reST 可扩展的部分,
在 Sphinx 中使用了大量的这种标记.</p>
<p>最基本的, 一个指示符包含一个名字, 参数, 选项和内容.
(请记住这个术语, 它将在下一章描述) 请看下面的例子,</p>
<pre class="literal-block">
.. function:: foo(x)
              foo(y, z)
   :bar: no

   Return a line of text input from the user.
</pre>
<p><tt class="docutils literal">function</tt> 是一个指示符的名字. 此处给了两个参数 (即前面两行剩下的),
和选项 <tt class="docutils literal">bar</tt> (就像你看到的, 选项是紧跟参数的, 并且通过冒号指明).</p>
<p>而后面的内容, 则是在一个空白行之后, 并且相对于指示符的开头有一定的缩进.</p>
</div>
<div class="section" id="id11">
<h1>脚注</h1>
<p>对于脚注, 使用 <tt class="docutils literal"><span class="pre">[#]_</span></tt> 来标记脚注的位置, 并增加一个脚注的主体在文档的后面,
像这样:</p>
<pre class="literal-block">
Lorem ipsum [#]_ dolor sit amet ... [#]_

.. rubric:: Footnotes

.. [#] Text of the first footnote.
.. [#] Text of the second footnote.
</pre>
<p>你可以使用显式的数字.</p>
</div>
<div class="section" id="id12">
<h1>注释</h1>
<p>每一个显式的标记块如果没有一个合法的标记构造就会被认为是注释.</p>
</div>
<div class="section" id="id13">
<h1>代码的编码</h1>
<p>为了以最简单的方式包含一些特殊字符, 我们将使用 Unicode 字符,
但需要指明一种编码方式:</p>
<p>所有的 Python 文档的源代码都将是 UTF-8 的编码,
而生成的 HTML 文档也将是这种编码.</p>
</div>
<div class="section" id="gotchas">
<h1>Gotchas</h1>
<p>There are some problems one commonly runs into while authoring reST documents:</p>
<ul class="simple">
<li><strong>Separation of inline markup:</strong> As said above, inline markup spans must be
separated from the surrounding text by non-word characters, you have to use
an escaped space to get around that.</li>
</ul>
</div>
</div>


</html>
